local cc = require "script/CClient"

local box_size = 46
local box_z = 0.3
local board_width = 6
local board_height = 10
local move_speed = 10
local box_speed = 12

local p1_pos = 1 --1~6
local p1_startX = 140
local p1_startY = 138
local p1_historyX = 140
local p1_historyY = 45
local p1_dice = 1 --1~6
local p1_box = "/box1"
local p1_board = {}
local p1_history = {}
local p1_shooting = false


-- 达到十行分胜负. 加入手势, 清理代码
--一个有效input之后要禁止输入, 对应动画效果播放完毕之后才允许输入; 最后加入p2, 合并p1p2功能
function init(self)
    cc.init(on_state_change)
    msg.post(p1_box, "disable")
    msg.post(".", "acquire_input_focus")
end

function on_state_change(state)
    local newstate = state.players[cc.id];
    update_board(newstate.board)
    update_history(newstate.history)
    if newstate.pos ~= p1_pos then
        p1_pos = newstate.pos
        go.animate("/p1", "position.x", go.PLAYBACK_ONCE_FORWARD, p1_startX + p1_pos * box_size, go.EASING_LINEAR, 1 / move_speed)
    end
    if newstate.dice ~= p1_dice then
        p1_dice = newstate.dice
        msg.post("/dice1#sprite", "play_animation", { id = hash(newstate.dice) })
    end
end

function update_board(b)
    go.delete(p1_board)
    p1_board = {}
    for i, v in ipairs(b.items) do
        local px = p1_startX + ((i - 1) % board_width + 1) * box_size;
        local py = p1_startY + (board_height - math.floor((i - 1) / board_width) - 1) * box_size;
        if v > 0 then
            local p = vmath.vector3(px, py, box_z)
            local piece = factory.create("/board#factory", p)
            msg.post(msg.url(nil, piece, "sprite"), "play_animation", { id = hash(v) })
            p1_board[i] = piece
        end
    end
end

function update_history(h)
    go.delete(p1_history)
    p1_history = {}
    local empty = (board_width - #h.items) * box_size
    for i, v in ipairs(h.items) do
        local px = empty + p1_historyX + ((i - 1) % board_width + 1) * box_size;
        local p = vmath.vector3(px, p1_historyY, box_z)
        local piece = factory.create("/board#factory", p)
        msg.post(msg.url(nil, piece, "sprite"), "play_animation", { id = hash(v) })
        p1_history[i] = piece
    end
end

function test_callback()
    print("test ok.")
end

function final(self)
    -- Add finalization code here
    -- Learn more: https://defold.com/manuals/script/
    -- Remove this function if not needed
end

function update(self, dt)
    if p1_shooting then
        local p1_box_pos = go.get_position(p1_box)
        local p1u = math.ceil((p1_box_pos.x - p1_startX) / box_size)
        local p1v = board_height - math.ceil((p1_box_pos.y - p1_startY) / box_size)
        local p1i = (p1v - 1) * board_width + p1u
        if p1_board[p1i] ~= nil then
            local n = go.get(msg.url(nil, p1_board[p1i], "sprite"), "animation")
            if n == hash(p1_dice) then
                msg.post(msg.url(nil, p1_board[p1i], "sprite"), "play_animation", { id = hash("boom") })
                cc.send("shoot", { i = p1i })
            end
            msg.post(p1_box, "disable")
            p1_shooting = false
        end

        p1_box_pos = go.get_position(p1_box) + vmath.vector3(0, box_speed, 0);
        go.set_position(p1_box_pos, p1_box)
        if p1v <= 0 then
            msg.post(p1_box, "disable")
            p1_shooting = false
        end
    end

end

function on_message(self, message_id, message, sender)
    if message_id == hash("on_gesture") then
        if message.swipe_right then
            print(message.swipe.from, message.swipe.to)
        elseif message.tap then
            print(message.tap.position)
        elseif message.double_tap then
            print(message.double_tap.position)
        elseif message.long_press then
            print(g.long_press.position, message.long_press.time)
        end

    end
end

function on_input(self, action_id, action)
    if action.released then
        if action_id == hash("left") then
            if (p1_pos > 1) then
                cc.send("move", { dir = "l" })
            end
        elseif action_id == hash("right") then
            if (p1_pos < board_width) then
                cc.send("move", { dir = "r" })
            end
        elseif action_id == hash("up") then
            if p1_shooting == false then
                local p = vmath.vector3(p1_startX + p1_pos * box_size, p1_startY, box_z)
                go.set_position(p, p1_box)
                msg.post(msg.url(nil, p1_box, "sprite"), "play_animation", { id = hash(p1_dice) })
                msg.post(p1_box, "enable")
                p1_shooting = true
            end
        elseif action_id == hash("down") then
            if (#p1_history>=board_width/2) then
                cc.send("magic")
            end
        elseif action_id == hash("roll") then
            cc.send("roll")
        end
    end

end

function on_reload(self)
    -- Add reload-handling code here
    -- Learn more: https://defold.com/manuals/hot-reload/
    -- Remove this function if not needed
end
